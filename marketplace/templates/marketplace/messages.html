{% extends "marketplace/base_marketplace.html" %}

{% block marketplace_title %}Messages{% endblock %}
{% block marketplace_header %}Messages{% endblock %}
{% block marketplace_subtitle %}Communicate with buyers and sellers{% endblock %}

{% block breadcrumbs %}
<li class="text-primary">Messages</li>
{% endblock %}

{% block marketplace_content %}
<!-- Messaging UI: inbox + chat window. This template includes a minimal AJAX skeleton that:
     - Starts or fetches a thread by listing_id or thread_id via query params
     - Polls periodically to fetch new messages
     - Sends messages as JSON POSTs
     Upgrade path: Replace polling with a WebSocket (Django Channels) to push updates in real-time.
-->
<div class="flex items-center gap-2 mb-2 lg:hidden">
  <button id="sidebarToggleBtn" class="btn btn-ghost btn-square" aria-label="Open sidebar" aria-controls="conversationSidebar" aria-expanded="false">
    <i class="fas fa-bars"></i>
  </button>
  <span class="text-sm text-base-content/70">Conversations</span>
</div>
<div id="sidebarOverlay" class="fixed inset-0 z-40 bg-black/40 opacity-0 pointer-events-none transition-opacity duration-300 ease-in-out lg:hidden"></div>

<div class="h-[calc(100vh-200px)] flex flex-col lg:flex-row gap-4">
    <!-- Conversations Sidebar (placeholder list) -->
    <aside id="conversationSidebar" class="w-80 max-w-[85vw] lg:w-1/3 bg-base-200 rounded-xl flex flex-col fixed inset-y-0 left-0 z-50 transform -translate-x-full transition-transform duration-300 ease-in-out lg:static lg:translate-x-0 lg:z-auto" role="complementary" aria-label="Conversations Sidebar">
        <!-- Sidebar Header -->
        <div class="p-4 border-b border-base-300">
            <div class="flex items-center justify-between mb-4">
                <h2 class="text-xl font-bold">Conversations</h2>
                <button class="btn btn-ghost btn-sm" onclick="refreshConversations()">
                    <i class="fas fa-sync-alt"></i>
                </button>
            </div>
            <!-- Search Conversations -->
            <div class="form-control">
                <div class="input-group">
                    <input type="text" placeholder="Search conversations..." class="input input-bordered input-sm flex-1" id="conversationSearch" onkeyup="filterConversations()">
                    <button class="btn btn-square btn-sm"><i class="fas fa-search"></i></button>
                </div>
            </div>
        </div>
        <!-- Conversations List (static placeholders) -->
        <div class="flex-1 overflow-y-auto" id="conversationsList">
            <div class="p-4 text-sm text-base-content/60">Start a conversation from a listing to see it here.</div>
        </div>
    </aside>

    <!-- Chat Window -->
    <section class="flex-1 bg-base-200 rounded-xl flex flex-col">
      <!-- Chat Header -->
      <div class="p-4 border-b border-base-300" id="chatHeader">
        <div class="flex items-center justify-between">
          <div>
            <h3 class="font-semibold" id="chatUsername">Messages</h3>
            <p class="text-sm text-base-content/70" id="chatProduct">Select a listing or pass ?listing_id= in the URL</p>
          </div>
        </div>
      </div>

      <!-- Messages Area -->
      <div class="flex-1 overflow-y-auto p-4 space-y-4" id="messagesArea"></div>

      <!-- Message Input -->
      <form id="messageForm" class="p-4 border-t border-base-300 flex items-end gap-2">
        <textarea id="messageInput" class="textarea textarea-bordered textarea-sm flex-1" placeholder="Type a message" rows="1" maxlength="4000" oninput="autoResize(this)"></textarea>
        <button id="sendButton" type="submit" class="btn btn-primary" disabled>Send</button>
      </form>
    </section>
</div>

<script>
// Client-side helpers and minimal AJAX wiring for messaging
let currentThreadId = null;
let lastMessageId = 0;
let currentUserId = {{ current_user_id|default:"null" }};
let currentUsername = "{{ current_username|default:"" }}";

/** Get CSRF token from cookie for safe POST requests */
function getCSRFToken() {
  const name = 'csrftoken=';
  const cookies = document.cookie.split(';');
  for (let c of cookies) { c = c.trim(); if (c.startsWith(name)) return c.substring(name.length); }
  return '';
}

/** Auto-resize textarea */
function autoResize(el) { el.style.height = 'auto'; el.style.height = (el.scrollHeight) + 'px'; document.getElementById('sendButton').disabled = !el.value.trim(); }

/** Render a single message bubble based on sender alignment */
function renderMessageBubble(msg) {
  const isMe = msg.sender_id === currentUserId;
  const sideClass = isMe ? 'chat-end' : 'chat-start';
  const bubbleClass = isMe ? 'chat-bubble-secondary' : 'chat-bubble-primary';
  const avatarBg = isMe ? 'bg-secondary text-secondary-content' : 'bg-primary text-primary-content';
  const headerName = isMe ? 'You' : `@${msg.sender_username || 'user'}`;
  const timeText = new Date(msg.created_at).toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'});
  return `
    <div class="chat ${sideClass}">
      <div class="chat-image avatar">
        <div class="w-8 rounded-full ${avatarBg} flex items-center justify-center">
          <span class="text-xs">${(msg.sender_username || 'U')[0].toUpperCase()}</span>
        </div>
      </div>
      <div class="chat-header">${headerName}<time class="text-xs opacity-50 ml-2">${timeText}</time></div>
      <div class="chat-bubble ${bubbleClass}">${msg.content}</div>
    </div>`;
}

/** Render a list of messages into the messages area */
function renderMessages(messages, {append = false} = {}) {
  const area = document.getElementById('messagesArea');
  let html = append ? area.innerHTML : '';
  for (const m of messages) {
    html += renderMessageBubble(m);
    if (m.id && m.id > lastMessageId) lastMessageId = m.id;
  }
  area.innerHTML = html;
  area.scrollTop = area.scrollHeight;
}

/** Start or get a thread for a given listing_id */
async function startOrGetThread(listingId) {
  const resp = await fetch('/marketplace/api/messages/thread/start/', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json', 'X-CSRFToken': getCSRFToken() },
    body: JSON.stringify({listing_id: parseInt(listingId, 10)})
  });
  if (!resp.ok) { showMarketplaceToast('Failed to start conversation.', 'error'); return; }
  const data = await resp.json();
  currentThreadId = data.thread.id;
  lastMessageId = 0;
  renderMessages(data.messages || [], {append: false});
}

/** Fetch messages for currentThreadId, optionally after a specific id */
async function fetchMessages(afterId = 0) {
  if (!currentThreadId) return;
  const url = `/marketplace/api/messages/thread/${currentThreadId}/messages/?after_id=${afterId}&limit=50`;
  const resp = await fetch(url, {method: 'GET'});
  if (!resp.ok) return;
  const data = await resp.json();
  if (Array.isArray(data.messages) && data.messages.length) { renderMessages(data.messages, {append: true}); }
}

/** Poll for new messages every few seconds */
function pollNewMessages() { fetchMessages(lastMessageId); }

/** Send a message via JSON POST */
async function sendMessage() {
  const messageInput = document.getElementById('messageInput');
  const content = (messageInput.value || '').trim();
  if (!content) return;
  if (!currentThreadId) { showMarketplaceToast('No active conversation.', 'error'); return; }
  const resp = await fetch(`/marketplace/api/messages/thread/${currentThreadId}/send/`, {
    method: 'POST', headers: { 'Content-Type': 'application/json', 'X-CSRFToken': getCSRFToken() },
    body: JSON.stringify({content})
  });
  if (!resp.ok) { showMarketplaceToast('Failed to send message.', 'error'); return; }
  const data = await resp.json();
  renderMessages([data.message], {append: true});
  messageInput.value = ''; messageInput.style.height = 'auto'; document.getElementById('sendButton').disabled = true;
}

/** Initialize messaging based on URL query params */
function initThreadFromQuery() {
  const params = new URLSearchParams(window.location.search);
  const listingId = params.get('listing_id');
  const threadId = params.get('thread_id');
  if (threadId) { currentThreadId = parseInt(threadId, 10); lastMessageId = 0; fetchMessages(0); return; }
  if (listingId) { startOrGetThread(listingId); return; }
}

// Hook initialization and polling
window.addEventListener('DOMContentLoaded', () => {
  // Form submission handler
  document.getElementById('messageForm').addEventListener('submit', (e) => { e.preventDefault(); sendMessage(); });
  // Input auto-resize
  document.getElementById('messageInput').addEventListener('input', function() { autoResize(this); });
  // Initialize thread from URL
  initThreadFromQuery();
  // Start polling every 3 seconds
  setInterval(() => { pollNewMessages(); }, 3000);
});

// Placeholder sidebar helpers
function refreshConversations() { /* fetch and render conversation list later */ }
function filterConversations() { /* client-side filter later */ }
</script>
{% endblock %}